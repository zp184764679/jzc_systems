# RFQ å¼‚æ­¥åˆ†ç±»å‰ç«¯é›†æˆæŒ‡å—

## ğŸ“‹ é›†æˆæ¦‚è¿°

åç«¯å·²æ”¯æŒ RFQ å¼‚æ­¥åˆ†ç±»ï¼Œå‰ç«¯éœ€è¦å®ç°ä»¥ä¸‹åŠŸèƒ½ï¼š
1. åˆ›å»º RFQ åç«‹å³è¿”å›ï¼ˆä¸å†ç­‰å¾…åˆ†ç±»å®Œæˆï¼‰
2. æ˜¾ç¤ºåˆ†ç±»è¿›åº¦
3. è½®è¯¢æˆ–æ¥æ”¶åˆ†ç±»å®Œæˆé€šçŸ¥
4. å®Œæˆååˆ·æ–°æ•°æ®

---

## ğŸ¯ æ ¸å¿ƒå®ç°

### 1. ä¿®æ”¹ RFQ åˆ›å»ºé€»è¾‘

**æ–‡ä»¶**: `frontend/src/pages/RFQ/CreateRFQ.jsx` (æˆ–ç±»ä¼¼æ–‡ä»¶)

```javascript
import { useState } from 'react';
import { message, Progress, Spin } from 'antd';

const CreateRFQ = () => {
  const [classificationStatus, setClassificationStatus] = useState(null);
  const [progress, setProgress] = useState(0);

  const handleCreateRFQ = async (values) => {
    try {
      // åˆ›å»º RFQ
      const response = await fetch('/api/v1/rfqs', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          pr_id: values.pr_id,
          note: values.note
        })
      });

      if (!response.ok) {
        throw new Error('åˆ›å»ºå¤±è´¥');
      }

      const rfq = await response.json();
      message.success('RFQ åˆ›å»ºæˆåŠŸï¼Œæ­£åœ¨åˆ†ç±»ç‰©æ–™...');

      // æ£€æŸ¥æ˜¯å¦éœ€è¦å¼‚æ­¥åˆ†ç±»
      if (rfq.classification_status === 'processing' || rfq.classification_status === 'pending') {
        setClassificationStatus('processing');
        pollClassificationStatus(rfq.id);
      } else {
        // åŒæ­¥åˆ†ç±»å·²å®Œæˆï¼Œç›´æ¥è·³è½¬
        navigate(`/rfqs/${rfq.id}`);
      }

    } catch (error) {
      message.error(error.message);
    }
  };

  const pollClassificationStatus = async (rfqId) => {
    const pollInterval = setInterval(async () => {
      try {
        const response = await fetch(`/api/v1/rfqs/${rfqId}/classification-status`);
        const data = await response.json();

        // æ›´æ–°è¿›åº¦
        setProgress(data.progress.percentage);

        // æ£€æŸ¥çŠ¶æ€
        if (data.classification_status === 'completed') {
          clearInterval(pollInterval);
          setClassificationStatus('completed');
          message.success('ç‰©æ–™åˆ†ç±»å®Œæˆï¼');

          // è·³è½¬åˆ° RFQ è¯¦æƒ…é¡µ
          setTimeout(() => {
            navigate(`/rfqs/${rfqId}`);
          }, 500);
        }

        if (data.classification_status === 'failed') {
          clearInterval(pollInterval);
          setClassificationStatus('failed');
          message.error('åˆ†ç±»å¤±è´¥ï¼Œè¯·é‡è¯•æˆ–è”ç³»ç®¡ç†å‘˜');
        }

      } catch (error) {
        console.error('è½®è¯¢å¤±è´¥:', error);
      }
    }, 2000); // æ¯2ç§’æŸ¥è¯¢ä¸€æ¬¡

    // è®¾ç½®è¶…æ—¶ä¿æŠ¤ï¼ˆæœ€å¤šè½®è¯¢5åˆ†é’Ÿï¼‰
    setTimeout(() => {
      clearInterval(pollInterval);
      if (classificationStatus === 'processing') {
        message.warning('åˆ†ç±»æ—¶é—´è¾ƒé•¿ï¼Œè¯·ç¨ååˆ·æ–°æŸ¥çœ‹');
      }
    }, 300000);
  };

  return (
    <div>
      {/* åŸæœ‰è¡¨å• */}
      <Form onFinish={handleCreateRFQ}>
        {/* ... */}
      </Form>

      {/* åˆ†ç±»è¿›åº¦æ˜¾ç¤º */}
      {classificationStatus === 'processing' && (
        <div style={{
          position: 'fixed',
          top: '50%',
          left: '50%',
          transform: 'translate(-50%, -50%)',
          background: 'white',
          padding: '40px',
          borderRadius: '8px',
          boxShadow: '0 4px 12px rgba(0,0,0,0.15)',
          minWidth: '400px',
          textAlign: 'center'
        }}>
          <Spin size="large" />
          <h3 style={{ marginTop: '20px' }}>æ­£åœ¨åˆ†ç±»ç‰©æ–™...</h3>
          <Progress percent={progress} status="active" />
          <p style={{ marginTop: '10px', color: '#666' }}>
            åˆ†ç±»å®Œæˆåå°†è‡ªåŠ¨è·³è½¬
          </p>
        </div>
      )}
    </div>
  );
};

export default CreateRFQ;
```

---

### 2. RFQ è¯¦æƒ…é¡µæ˜¾ç¤ºåˆ†ç±»çŠ¶æ€

**æ–‡ä»¶**: `frontend/src/pages/RFQ/RFQDetail.jsx`

```javascript
import { useEffect, useState } from 'react';
import { useParams } from 'react-router-dom';
import { Tag, Progress, Alert } from 'antd';
import { SyncOutlined, CheckCircleOutlined } from '@ant-design/icons';

const RFQDetail = () => {
  const { id } = useParams();
  const [rfq, setRfq] = useState(null);
  const [classificationStatus, setClassificationStatus] = useState(null);

  useEffect(() => {
    fetchRFQDetails();
    checkClassificationStatus();
  }, [id]);

  const fetchRFQDetails = async () => {
    const response = await fetch(`/api/v1/rfqs/${id}`);
    const data = await response.json();
    setRfq(data);
  };

  const checkClassificationStatus = async () => {
    try {
      const response = await fetch(`/api/v1/rfqs/${id}/classification-status`);
      const data = await response.json();

      setClassificationStatus(data);

      // å¦‚æœè¿˜åœ¨åˆ†ç±»ä¸­ï¼Œç»§ç»­è½®è¯¢
      if (data.classification_status === 'processing' || data.classification_status === 'pending') {
        setTimeout(checkClassificationStatus, 2000);
      } else if (data.classification_status === 'completed') {
        // åˆ†ç±»å®Œæˆï¼Œåˆ·æ–°è¯¦æƒ…
        fetchRFQDetails();
      }
    } catch (error) {
      console.error('è·å–åˆ†ç±»çŠ¶æ€å¤±è´¥:', error);
    }
  };

  const renderClassificationBanner = () => {
    if (!classificationStatus) return null;

    const { classification_status, progress } = classificationStatus;

    if (classification_status === 'processing' || classification_status === 'pending') {
      return (
        <Alert
          message="ç‰©æ–™åˆ†ç±»ä¸­"
          description={
            <div>
              <p>æ­£åœ¨ä½¿ç”¨AIåˆ†ç±»ç‰©æ–™ï¼Œé¢„è®¡éœ€è¦ {Math.ceil(progress.total / 2)} ç§’...</p>
              <Progress
                percent={progress.percentage}
                status="active"
                strokeColor={{ from: '#108ee9', to: '#87d068' }}
              />
            </div>
          }
          type="info"
          icon={<SyncOutlined spin />}
          showIcon
          style={{ marginBottom: '16px' }}
        />
      );
    }

    if (classification_status === 'completed') {
      return (
        <Alert
          message="ç‰©æ–™åˆ†ç±»å®Œæˆ"
          description={`å·²æˆåŠŸåˆ†ç±» ${progress.total} é¡¹ç‰©æ–™`}
          type="success"
          icon={<CheckCircleOutlined />}
          showIcon
          closable
          style={{ marginBottom: '16px' }}
        />
      );
    }

    if (classification_status === 'failed') {
      return (
        <Alert
          message="åˆ†ç±»å¤±è´¥"
          description="ç‰©æ–™åˆ†ç±»è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯ï¼Œè¯·é‡æ–°åˆ›å»ºRFQæˆ–è”ç³»ç®¡ç†å‘˜"
          type="error"
          showIcon
          closable
          style={{ marginBottom: '16px' }}
        />
      );
    }

    return null;
  };

  return (
    <div>
      {renderClassificationBanner()}

      {/* RFQ è¯¦æƒ…å†…å®¹ */}
      {rfq && (
        <div>
          {/* ç‰©æ–™åˆ—è¡¨ */}
          {rfq.items.map(item => (
            <div key={item.id}>
              {/* å¦‚æœè¿˜åœ¨åˆ†ç±»ä¸­ï¼Œæ˜¾ç¤ºå ä½ç¬¦ */}
              {item.category === 'åˆ†ç±»ä¸­...' ? (
                <Tag icon={<SyncOutlined spin />} color="processing">
                  åˆ†ç±»ä¸­...
                </Tag>
              ) : (
                <Tag color="blue">{item.category}</Tag>
              )}
              {item.item_name}
            </div>
          ))}
        </div>
      )}
    </div>
  );
};

export default RFQDetail;
```

---

### 3. API å°è£…ï¼ˆæ¨èï¼‰

**æ–‡ä»¶**: `frontend/src/api/rfq.js`

```javascript
// RFQ API å°è£…
export const rfqAPI = {
  // åˆ›å»º RFQ
  async create(data) {
    const response = await fetch('/api/v1/rfqs', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    });

    if (!response.ok) {
      throw new Error('åˆ›å»ºå¤±è´¥');
    }

    return response.json();
  },

  // è·å– RFQ è¯¦æƒ…
  async getDetail(id) {
    const response = await fetch(`/api/v1/rfqs/${id}`);

    if (!response.ok) {
      throw new Error('è·å–è¯¦æƒ…å¤±è´¥');
    }

    return response.json();
  },

  // è·å–åˆ†ç±»çŠ¶æ€
  async getClassificationStatus(id) {
    const response = await fetch(`/api/v1/rfqs/${id}/classification-status`);

    if (!response.ok) {
      throw new Error('è·å–åˆ†ç±»çŠ¶æ€å¤±è´¥');
    }

    return response.json();
  },

  // è½®è¯¢åˆ†ç±»çŠ¶æ€ï¼ˆè¿”å›Promiseï¼Œå®Œæˆæ—¶resolveï¼‰
  async waitForClassification(rfqId, onProgress, timeout = 300000) {
    return new Promise((resolve, reject) => {
      const startTime = Date.now();

      const poll = async () => {
        try {
          const status = await this.getClassificationStatus(rfqId);

          // å›è°ƒè¿›åº¦
          if (onProgress) {
            onProgress(status);
          }

          // æ£€æŸ¥å®Œæˆ
          if (status.classification_status === 'completed') {
            resolve(status);
            return;
          }

          // æ£€æŸ¥å¤±è´¥
          if (status.classification_status === 'failed') {
            reject(new Error('åˆ†ç±»å¤±è´¥'));
            return;
          }

          // æ£€æŸ¥è¶…æ—¶
          if (Date.now() - startTime > timeout) {
            reject(new Error('åˆ†ç±»è¶…æ—¶'));
            return;
          }

          // ç»§ç»­è½®è¯¢
          setTimeout(poll, 2000);

        } catch (error) {
          reject(error);
        }
      };

      poll();
    });
  }
};
```

---

### 4. React Hook å°è£…ï¼ˆé«˜çº§ï¼‰

**æ–‡ä»¶**: `frontend/src/hooks/useRFQClassification.js`

```javascript
import { useState, useEffect, useCallback } from 'react';
import { rfqAPI } from '@/api/rfq';

export const useRFQClassification = (rfqId) => {
  const [status, setStatus] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const fetchStatus = useCallback(async () => {
    if (!rfqId) return;

    try {
      setLoading(true);
      const data = await rfqAPI.getClassificationStatus(rfqId);
      setStatus(data);

      // å¦‚æœè¿˜åœ¨åˆ†ç±»ä¸­ï¼Œç»§ç»­è½®è¯¢
      if (data.classification_status === 'processing' || data.classification_status === 'pending') {
        setTimeout(fetchStatus, 2000);
      }

    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }, [rfqId]);

  useEffect(() => {
    fetchStatus();
  }, [fetchStatus]);

  return {
    status,
    loading,
    error,
    isProcessing: status?.classification_status === 'processing' || status?.classification_status === 'pending',
    isCompleted: status?.classification_status === 'completed',
    isFailed: status?.classification_status === 'failed',
    progress: status?.progress || { percentage: 0 }
  };
};

// ä½¿ç”¨ç¤ºä¾‹
function RFQDetailPage() {
  const { id } = useParams();
  const { status, isProcessing, progress } = useRFQClassification(id);

  return (
    <div>
      {isProcessing && (
        <Progress percent={progress.percentage} status="active" />
      )}
      {/* ... */}
    </div>
  );
}
```

---

## ğŸ¨ UI ç»„ä»¶å»ºè®®

### åˆ†ç±»è¿›åº¦å¡ç‰‡ç»„ä»¶

```jsx
import { Card, Progress, Spin } from 'antd';
import { SyncOutlined } from '@ant-design/icons';

const ClassificationProgress = ({ percentage, totalItems, classifiedItems }) => {
  return (
    <Card
      style={{
        background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
        color: 'white',
        borderRadius: '12px'
      }}
    >
      <div style={{ textAlign: 'center' }}>
        <Spin indicator={<SyncOutlined spin style={{ fontSize: 32, color: 'white' }} />} />
        <h3 style={{ color: 'white', marginTop: '16px' }}>
          æ­£åœ¨æ™ºèƒ½åˆ†ç±»ç‰©æ–™
        </h3>
        <Progress
          percent={percentage}
          strokeColor="white"
          trailColor="rgba(255,255,255,0.3)"
          format={percent => `${percent}%`}
        />
        <p style={{ marginTop: '12px', opacity: 0.9 }}>
          å·²åˆ†ç±» {classifiedItems} / {totalItems} é¡¹
        </p>
      </div>
    </Card>
  );
};
```

---

## âš™ï¸ é…ç½®å»ºè®®

### è½®è¯¢ç­–ç•¥

```javascript
// æ™ºèƒ½è½®è¯¢é—´éš”ï¼ˆæ ¹æ®è¿›åº¦è°ƒæ•´ï¼‰
function getPollingInterval(percentage) {
  if (percentage < 20) return 3000;   // å‰æœŸ3ç§’
  if (percentage < 80) return 2000;   // ä¸­æœŸ2ç§’
  return 1000;                         // åæœŸ1ç§’ï¼ˆå¿«å®Œæˆäº†ï¼‰
}
```

### é”™è¯¯é‡è¯•

```javascript
async function pollWithRetry(rfqId, maxRetries = 3) {
  let retries = 0;

  const poll = async () => {
    try {
      return await rfqAPI.getClassificationStatus(rfqId);
    } catch (error) {
      retries++;
      if (retries < maxRetries) {
        console.log(`é‡è¯• ${retries}/${maxRetries}...`);
        await new Promise(r => setTimeout(r, 1000));
        return poll();
      }
      throw error;
    }
  };

  return poll();
}
```

---

## ğŸ“± ç§»åŠ¨ç«¯é€‚é…

```css
/* ç§»åŠ¨ç«¯è¿›åº¦æ˜¾ç¤º */
@media (max-width: 768px) {
  .classification-progress {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    background: white;
    padding: 16px;
    box-shadow: 0 -2px 8px rgba(0,0,0,0.1);
    z-index: 1000;
  }
}
```

---

## ğŸ§ª æµ‹è¯•è¦ç‚¹

1. **åˆ›å»ºRFQ** â†’ åº”ç«‹å³è¿”å›ï¼Œæ˜¾ç¤ºåˆ†ç±»è¿›åº¦
2. **è½®è¯¢** â†’ æ¯2ç§’æ›´æ–°ä¸€æ¬¡è¿›åº¦
3. **å®Œæˆ** â†’ è‡ªåŠ¨åˆ·æ–°è¯¦æƒ…ï¼Œæ˜¾ç¤ºåˆ†ç±»ç»“æœ
4. **å¤±è´¥** â†’ æ˜¾ç¤ºé”™è¯¯æç¤ºï¼Œå…è®¸é‡è¯•
5. **è¶…æ—¶** â†’ 5åˆ†é’Ÿååœæ­¢è½®è¯¢ï¼Œæç¤ºç”¨æˆ·åˆ·æ–°

---

## ğŸ“ å¸¸è§é—®é¢˜

### Q: ä¸ºä»€ä¹ˆè¦è½®è¯¢è€Œä¸æ˜¯ WebSocket?
A: è½®è¯¢å®ç°ç®€å•ï¼Œå¯¹äºä½é¢‘æ›´æ–°ï¼ˆæ¯2ç§’ï¼‰è¶³å¤Ÿé«˜æ•ˆã€‚æœªæ¥å¯å‡çº§ä¸º SSE æˆ– WebSocketã€‚

### Q: å¦‚æœç”¨æˆ·å…³é—­é¡µé¢ä¼šæ€æ ·?
A: åå°åˆ†ç±»ä»ä¼šç»§ç»­ï¼Œç”¨æˆ·ä¸‹æ¬¡è®¿é—®æ—¶çœ‹åˆ°å·²åˆ†ç±»å®Œæˆçš„ç»“æœã€‚

### Q: åˆ†ç±»å¤±è´¥æ€ä¹ˆåŠ?
A: æ˜¾ç¤ºé”™è¯¯æç¤ºï¼Œç”¨æˆ·å¯ä»¥é‡æ–°åˆ›å»º RFQ æˆ–è”ç³»ç®¡ç†å‘˜ã€‚å¤±è´¥åŸå› ä¼šè®°å½•åœ¨æ—¥å¿—ä¸­ã€‚

---

**å®Œæˆæ—¶é—´**: 2025-11-08
**ç‰ˆæœ¬**: v1.0
